<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>What's difficult about forcing? | Jason Zesheng Chen</title> <meta name="author" content="Jason Zesheng Chen"> <meta name="description" content="An introductory overview of forcing, from the learner's perspective"> <meta name="keywords" content="jekyll, jasonzeshengchen, academic-website, portfolio-website, Zesheng"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-xOolHFLEh07PJGoPkLv1IbcEPTNtaed2xpHsD9ESMhqIYd0nLMwNLD69Npy4HI+N" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.1/css/all.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicon_package/apple-touch-icon.png"> <link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicon_package/favicon-32x32.png"> <link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicon_package/favicon-16x16.png"> <link rel="manifest" href="/assets/img/favicon_package/site.webmanifest"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://jasonzeshengchen.github.io/blog/2022/what-is-difficult-about-forcing/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">{
      "title": "What's difficult about forcing?",
      "description": "An introductory overview of forcing, from the learner's perspective",
      "published": "January 20, 2022",
      "authors": [
        {
          "author": "Jason Zesheng Chen",
          "authorURL": "",
          "affiliations": [
            {
              "name": "",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">Jason Zesheng Chen</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Research</a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="/research/">overview</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/publications/">publications</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/presentations/">presentations</a> </div> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">Teaching</a> </li> <li class="nav-item "> <a class="nav-link" href="/notes/">Notes</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>What's difficult about forcing?</h1> <p>An introductory overview of forcing, from the learner's perspective</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#what-is-forcing">What is forcing?</a></div> <div><a href="#i-thought-we-were-talking-about-proving-things-so-why-models">I thought we were talking about proving things. So why models?</a></div> <div><a href="#countable-transitive-models">Countable Transitive Models</a></div> <div><a href="#so-we-have-a-countable-transitive-model-what-can-we-do-with-it">So we have a countable transitive model. What can we do with it?</a></div> <div><a href="#poset-and-filter">Poset and Filter</a></div> <div><a href="#do-m-generic-filters-exist">Do M-generic filters exist?</a></div> <div><a href="#what-about-all-the-sets-generated-by-the-generic-object">What about all the sets generated by the generic object?</a></div> <div><a href="#enter-the-names">Enter the Names</a></div> <div><a href="#evaluation-by-a-generic-filter">Evaluation by a generic filter</a></div> <div><a href="#generic-extensions">Generic Extensions</a></div> <div><a href="#forcing-more-generally">Forcing more generally</a></div> <div><a href="#so-i-am-ready-to-learn-forcing-have-learned-forcing-what-now">So I am ready to learn forcing / have learned forcing. What now?</a></div> </nav> </d-contents> <p>Note: the goal of this article is to give a sense of the kind of difficulties, both conceptual and technical, one might encounter if one decides to learn the mathematical tool of forcing. As such it is not my intention to provide an intuitive motivation for forcing, or explain the inner workings of it in a perspicuous way. Already there are excellent sources for that: for example see <a href="https://www.mcmp.philosophie.uni-muenchen.de/students/math/toby_meadows/meadows_philo_guide_forcing.pdf" rel="external nofollow noopener" target="_blank">A Philosopher’s Guide to Forcing</a> by Toby Meadows or <a href="http://timothychow.net/forcing.pdf" rel="external nofollow noopener" target="_blank">A Beginner’s Guide to Forcing</a> by Timothy Chow.</p> <p>What I intend to achieve here is somewhat particular: after a first course in formal logic, set theory, or Gödel’s theorems, a motivated student might see the term “forcing” pop up on the occasional Google chase. They might be intrigued as to why this technique won Paul Cohen, its discoverer, a Fields Medal, for instance. But “what is forcing” is a question that is highly difficult to address in office hours, because there are quite a few moving pieces involved. Each of these pieces brings its own special kind of unease to the student, making the whole thing quite daunting. It is simply my hope here to record these moving pieces their associated difficulties.</p> <p>Due to this peculiar aim, the article is sprinkled with pausing remarks (click to expand) on what is difficult about the matter at hand and whether it’s conceptual or technical. My judgment is that forcing is not substantially harder than any other main theorems in graduate math textbooks. It is simply due to the variety of concepts involved and the unfamiliarity of the tools used, that forcing has gained some kind of notoriety.</p> <p>An earlier simpler draft of this post was first published in Chinese on the Q &amp; A platform Zhihu. One may view the original version here: <a href="https://zhuanlan.zhihu.com/p/93294818" rel="external nofollow noopener" target="_blank">link to the Chinese version</a>.</p> <hr> <h2 id="what-is-forcing">What is forcing?</h2> <p>Forcing is the name of a technical method to establish <em>independence results</em> in set theory. These are results saying that certain statements <strong>cannot</strong> be deduced from the axioms of set theory (<a href="https://en.wikipedia.org/wiki/Zermelo%E2%80%93Fraenkel_set_theory" rel="external nofollow noopener" target="_blank">the Zermelo-Fraenkel axioms with Choice</a>).</p> <p>To show that a statement cannot be deduced from a theory, one shows that the negation of the statement is <em>consistent</em> with the theory. Given a mathematical theory $T$, we write $\mathsf{Con}(T)$ for the statement that $T$ is consistent: i.e., there is no proof that starts with the axioms of $T$ and ends with a contradiction.</p> <p>If for some sentence $P$ we succeed in showing $\mathsf{Con}(\mathsf{ZFC}+P)$, then we have succeeded in showing that $\mathsf{ZFC}$ cannot refute $P$. This is because if $\mathsf{ZFC}$ refutes $P$, then this means $\mathsf{ZFC}$ proves $\neg P$ (“not-P”); therefore from the theory $\mathsf{ZFC}+P$ one can deduce $P \wedge \neg P$, a contradiction, by doing the following: first deduce $\neg P$ from $\mathsf{ZFC}$ alone, and then deduce $P$.</p> <p>Forcing allows one to conclude, under suitable assumptions laid out below, $\mathsf{Con}(\mathsf{ZFC}+P)$ for various choices of $P$. Different people have different ways of understanding and implementing it, but arguably the most straightforward way to make sense of it is that it is a method of building new models of ZFC from old ones.</p> <hr> <h2 id="i-thought-we-were-talking-about-proving-things-so-why-models">I thought we were talking about proving things. So why models?</h2> <p>It turns out that talking about proofs is not the easiest thing to do. It is easier to work with models instead. A model of a theory, roughly put, is just a set of things that satisfies that theory. The connection between proofs and models was confirmed by Kurt Gödel in his doctoral thesis:</p> <blockquote> <p>Fact. (Gödel’s Completeness Theorem): $\mathsf{Con}(T)$ if and only if $T$ has a model.</p> </blockquote> <details><summary style="cursor: pointer">Technical Difficulties</summary> <div style="margin-left: 1em;"> A technical difficulty lies in understanding the statements $\mathsf{Con}(\mathsf{ZFC})$ and "$\mathsf{ZFC}$ has a model" as precise mathematical statements. <br><br> In the strictest sense, $\mathsf{Con}(\mathsf{ZFC})$ is to be construed as the number-theoretic claim that, roughly, there does not exist a natural number which in Unicode encodes a sequence of symbols, in which the starting lines are axioms of $\mathsf{ZFC}$, and the last line is the sentence $0=1$, and the intermediate lines are all obtained by valid rules of inferences in first-order logic. This whole business of encoding sequences of symbols by natural numbers is very fuzzy and not very fun to go through. Fortunately this accords with one's intuition how proofs work, so this is familiar territory for someone familiar with proofs. It's just painstakingly formalized in this case.<br><br> Fact: One can write down formulas $\mathsf{Axiom}(x)$, $\mathsf{isProof}(x,y)$ in the language of number theory, such that if number theory can prove $\mathsf{Axiom}(n)$, then $n$ really is the Unicode encoding of one of the $\mathsf{ZFC}$ axioms; and if number theory can prove $\mathsf{isProof}(a,b)$, then $a$ really is the Unicode encoding of a $\mathsf{ZFC}$-proof of the statement encoded by $b$. <br><br> Similarly, one needs to strictly formalize what a theory is and what it means for a theory to have a model. This is of course routine now in an advanced logic course, but it is highly unlikely that someone without a logic background can spell out what a model really is. Again, the good news is that this doesn't matter much, because it stays pretty close with our mathematical practice and intuition. </div> </details> <p><br></p> <p>So if our goal is to show that $\mathsf{ZFC}$ cannot deduce $P$ (so we want to show $\mathsf{Con}(\mathsf{ZFC}+\neg P)$), it is enough to build a model of $\mathsf{ZFC}+\neg P$. This shifts the focus from talking about proofs, which are strings of symbols generated by some fixed rule, to models, which are perhaps more tangible and familiar.</p> <p>Unfortunately, one cannot just build a model of $\mathsf{ZFC}$ out of thin air. Another theorem by Gödel, his second <em>in</em>completeness theorem, in simple terms states:</p> <blockquote> <p>If $\mathsf{ZFC}$ proves that $\mathsf{ZFC}$ has a model, then it can also deduce a contradiction.</p> </blockquote> <p>So if $\mathsf{ZFC}$ is consistent to begin with, we cannot use it to deduce $\mathsf{Con}(\mathsf{ZFC})$, let alone $\mathsf{Con}(\mathsf{ZFC}+P)$. This left us with the second best option: <em>assume</em> that $\mathsf{ZFC}$ is consistent, and then show $\mathsf{Con}(\mathsf{ZFC}+P)$.</p> <p>This is where models come in: assuming $\mathsf{ZFC}$ is consistent provides us with a model of it. With forcing, one can carefully pick out an element, add it to the model, and make sure that the resulting model does what one wants.</p> <hr> <h2 id="countable-transitive-models">Countable Transitive Models</h2> <p>Models of $\mathsf{ZFC}$ are very complex. A model of $\mathsf{ZFC}$ will contain everything that $\mathsf{ZFC}$ proves to exist (i.e., pretty much all of math). In particular, it proves that the following set exists: $\{f \mid f: \mathbb{N}\to \{0,1\}\}$. Intuitively, this is the set of all infinite sequences of zeroes and ones. <a href="https://en.wikipedia.org/wiki/Polish_space" rel="external nofollow noopener" target="_blank">There is a way of viewing them as the real numbers</a>, which is why set theorists and recursion theorists often like to refer to elements in this set as the real numbers. In particular, the set $\{f \mid f: \mathbb{N}\to \{0,1\}\}$, which we denote by $2^\mathbb{N}$, is uncountable.</p> <p>Paul Cohen invented forcing for the express purpose of adding such a $0-1$ sequence to a model of $\mathsf{ZFC}$. To do this, he restricted his attention to models of $\mathsf{ZFC}$ that he knew for sure would be missing at least one $0-1$ sequence: the countable transtive ones.</p> <details><summary style="cursor: pointer">Conceptual and Technical Difficulties</summary> <div style="margin-left: 1em;"> One of the first great stumbling blocks for learners of forcing (and mathematical logic really) is the existence of countable models of $\mathsf{ZFC}$. This presents a seeming contradictions of facts at hand: <br><br> 1. (Cantor's Theorem) $\mathsf{ZFC}$ proves that uncountable sets exist; in particular, the set of real numbers, or $2^\mathbb{N}$, is uncountable; but, <br> 2. (Downward Löwenheim-Skolem Theorem) If $\mathsf{ZFC}$ has any model at all, then it has a countable model. <br><br> These two facts seem to contradict each other in a confusing way. So much so that it deserves its own <a href="https://plato.stanford.edu/entries/paradox-skolem/" rel="external nofollow noopener" target="_blank">name and article in the Stanford Encyclopedia of Philosophy</a>. <br><br> The existence of countable models certainly presents conceptual difficulties for someone seeing this for the first time. Indeed this is one of those "you'll get used to it" bits in math. But perhaps let me give an intuitive explanation: <br><br> $\mathsf{ZFC}$ has only countably many formulas. This entails that the theory can only talk about countably many things. In particular, it can only define countably many things, and prove that they exist. A structure can be a model of $\mathsf{ZFC}$ if it doesn't rule out the existence of these things. So to obtain a model of $\mathsf{ZFC}$, we are only required to throw in the things that $\mathsf{ZFC}$ defines and proves to exist: there are only countably many of these! <br><br> What about the set of real numbers, which $\mathsf{ZFC}$ proves to exist? Well, we are only building a structure that satisfies a collection of sentences. There is no guarantee that we are really building the actual mathematical universe. Thus if $M$ is a countable model, $M$ is going to satisfy "there exists a unique set of real numbers", but we are not guaranteed in having that the unique set that $M$ judges to be the real numbers is really the set of all real numbers (although there might be overlap). </div> </details> <p><br></p> <p>A model $M$ is transitive if and only if $x\in M$ implies $x\subseteq M$. Intuitively, the model $M$ “sees” the elements of its elements, the elements of those elements, and so on. Transitive models are nice, in that if $M_1\subseteq M_2$ are transitive models, then they agree on the meaning of basic, simple terms. For instance, if $x\in M_1$ is such that $M_1$ satisfies the sentence $``x \text{ is the set of natural numbers}”$, then $M_2$ will satisfy the same sentence. Recall that the use of forcing is to build a model of $\mathsf{ZFC}$ on top of another one, so this $M_1\subseteq M_2$ situation is precisely what we will end up with. Therefore it is important to be able to hold the meaning of certain terms fixed across these two models.</p> <details><summary style="cursor: pointer">Technical Difficulties</summary> <div style="margin-left: 1em;"> One needs of course to define what "basic, simple terms" are and prove that they behave as intended. For those interested, these refer to the things on the $\Delta_1$ level of the <a href="https://en.wikipedia.org/wiki/L%C3%A9vy_hierarchy" rel="external nofollow noopener" target="_blank">Levy-hierarchy </a>. And the technical term for "holding the meaning fixed across models" is "<a href="https://en.wikipedia.org/wiki/Absoluteness" rel="external nofollow noopener" target="_blank">absoluteness</a>". <br><br> One should also note that "there exists a countable transitive model of $\mathsf{ZFC}$" is strictly stronger than "there exists a countable model of $\mathsf{ZFC}$". In fact, it is much, much stronger. One can show that "there exists a countable transitive model of $\mathsf{ZFC}$" implies $\mathsf{Con(ZFC)}$, $\mathsf{Con(ZFC+Con(ZFC))}$, $\mathsf{Con(ZFC+Con(ZFC+Con(ZFC)))}$, and so much more. <br><br> This means we are really cheating a little bit when we restrict attention to countable transitive models, whose existence is not really guaranteed by the starting assumption of merely $\mathsf{Con(ZFC)}$. The technical difficulty here lies in dispensing with the transitive model assumption while still working with it. <br><br> This is done via <a href="https://en.wikipedia.org/wiki/Reflection_principle%20%20" rel="external nofollow noopener" target="_blank">The Reflection Principle</a>, which says given any finite subset of the $\mathsf{ZFC}$ axioms, one can find a countable transitive model for that. And the proof of $\mathsf{Con(ZFC)}\rightarrow \mathsf{Con(ZFC+P)}$ proceeds in 2 steps: <br><br> 1. If $\mathsf{Con(ZFC+P)}$ does not hold, then it can deduce a contradiction in finitely many steps, using only finitely many axioms from $\mathsf{ZFC+P}$. Let's say it uses the axioms $A_1,...,A_{1024}, P$. <br> 2. But the forcing construction will also end up only using finitely many axioms of $\mathsf{ZFC}$, say the axioms $B_1,...,B_{2048}$. Using the Reflection Principle, one obtains a countable transitive model of $\{A_1,...,A_{1024}, B_1,...,B_{2048}\}$, and use forcing to produce a countable transitive model of $\{A_1,...,A_{1024}, B_1,...,B_{2048}, P\}$. But we just assumed the latter theory is inconsistent! <br> Therefore, working from the $\mathsf{ZFC}$ axioms $\{A_1,...,A_{1024}, B_1,...,B_{2048}\}$, we proved the existence of a model of $\{A_1,...,A_{1024}, P\}$. This is impossible, if $\mathsf{ZFC}$ is consistent. So our starting assumption must be wrong. Hence $\mathsf{Con(ZFC+P)}$ must hold. </div> </details> <p><br></p> <hr> <h2 id="so-we-have-a-countable-transitive-model-what-can-we-do-with-it">So we have a countable transitive model. What can we do with it?</h2> <p>Suppose $M$ is a countable transitive model of $\mathsf{ZFC}$. Since $M$ is countable, we know for sure that there are elements that $M$ is missing. The function telling us that $M$ is countable, for example ($g: M\leftrightarrow \mathbb{N}$). Another example is the “height of $M$”. This is a common name for the set of ordinals in $M$, that is $M \cap \text{ Ordinals}$. This is because being an ordinal is a basic, simple notion that $M$ correctly recognizes. So if $M \cap \text{ Ordinals}$ is an element of $M$, then $M$ will satisfy “the class of ordinals form a set”, and we know this isn’t a theorem of $\mathsf{ZFC}$.</p> <p>It is also clear that adding a single set to $M$ won’t be enough. This is because $\mathsf{ZFC}$ axioms are “generative” in spirit: if $x$ is a set, then $\{x\}$ is also a set; if $x,y$ are sets, then so is $\{x,y\}$, and so on. So whatever set we add to $M$, we will also have to add the sets that are generated by it, as required by the axioms. And the sets that are generated by those, ad infinitum.</p> <p>The point of the last two paragraphs is this: while we know there are plenty of things that cannot be in $M$, we need to be careful in what we want to add to it. For instance, it should be not too informative, in that it makes the countability of $M$, or the “set-ness” of its ordinals, obvious.</p> <p>Recall that our goal is to add a $0-1$ sequence to $M$. Such a sequence must exist, since there are uncountably many of these and $M$ is countable. But how do we pick out such a sequence? It cannot be too simple, because simple notions are guaranteed to exist; it cannot be too specific, because adding it to $M$ might not result in a model of $\mathsf{ZFC}$ any more. This was the challenge that Cohen faced, which he recounts in <a href="https://projecteuclid.org/journals/rocky-mountain-journal-of-mathematics/volume-32/issue-4/The-Discovery-of-Forcing/10.1216/rmjm/1181070010.full" rel="external nofollow noopener" target="_blank">his account of the discovery of forcing</a>.</p> <hr> <h2 id="poset-and-filter">Poset and Filter</h2> <p>The innovation of forcing derives from the remarkable decision that this sequence is going to be constructed using partial information. Given that our object of interest is an infinite $0-1$ sequence, we take partial information to mean the finite initial segments of the sequence.</p> <blockquote> <p>Definition. The Cohen poset (short for partially ordered set) is the set of finite sequences of $0-1$: $\{s\mid s: \{0,…,n\}\to \{0,1\}, n\in \mathbb N\}$.</p> </blockquote> <p>And the informal notion of construction using partial information is made precise by appealing to the notion of a filter.</p> <blockquote> <p>Definition. A filter on the Cohen poset is a collection $G$ of finite $0-1$ sequences that are coherent in the following sense: 1) the empty sequence is in $G$; 2) if a sequence is in $G$, then all the initial sequences of it is also in $G$; 3) if $s_0,s_1$ are two sequences in $G$, then one must be an extension of the other.</p> </blockquote> <p>For example, if $f: \mathbb N\to\{0,1\}$ is any $0-1$ sequence whatsoever, the set of all its initial segments will be a filter. This tells us that filters are not enough: each $0-1$ sequence corresponds to a filter. So this idea of “construct it using partial information” is too broad. It does not avoid the “too informative” or “too specific” or “too simple” problem. What’s missing is an additional restriction on the filters so that the object we end up obtaining is perfectly average: not too simple as to be fixed across all models, not too specific as to be generated outright in $M$, and not too informative as to be contradicting $\mathsf{ZFC}$.</p> <p>Cohen realized this missing restriction was to be the topological notion of genericity. In addition to being coherent, the filter is further required to pick out elements that are perfectly average in the following sense.</p> <blockquote> <p>Definition. A dense subset of the Cohen poset is one in which every finite $0-1$ sequence can find an extension. A filter is $M$-generic if it intersects every dense subset of the Cohen poset that is in $M$.</p> </blockquote> <p>So generic filters capture the idea of being not too specific.</p> <p>They are not too simple either. In fact, if $G$ is a $M$-generic filter on the Cohen poset, then it can be shown that $G$ is not an element of $M$. This is roughly because, if $G\in M$, then we can use $G$ to express the property of “not being in $G$” and show that the finite $0-1$ sequences having this property form a dense subset in $M$.</p> <p>We observe that, for each natural number $n$, the set of finite binary sequences of length at least $n$ is dense. Or in other words, it is a generic property of binary sequences to have length $\geq n$. So for each $n$, a generic filter will contain finite sequences of length at least $n$.</p> <p>This implies that the construction indeed gives us what we want. If $G$ is a $M$-generic filter, then piecing together its element (i.e., taking $\bigcup G$) gives us a genuine function $f: \mathbb N\to \{0,1\}$, an infinite $0-1$ sequence that is not in $M$.</p> <hr> <h2 id="do-m-generic-filters-exist">Do M-generic filters exist?</h2> <p>If $M$ is a countable transitive model, then yes. This result is known as the <a href="https://en.wikipedia.org/wiki/Rasiowa%E2%80%93Sikorski_lemma" rel="external nofollow noopener" target="_blank">Rasiow-Sikorski lemma</a>, proven about a decade before the invention of forcing.</p> <p>By all means this is one of those pleasant moments in mathematics where ideas from various fields converge. It turns out that the existence of a generic filter, which is motivated by our attempt to build an object outside of $M$ that is perfectly average, is a close relative to the Baire category theorem. The exact equivalence is spelled out in <a href="https://www.jstor.org/stable/2274230" rel="external nofollow noopener" target="_blank">this paper by Goldblatt</a>.</p> <p>The proof of the Rasiowa-Sikorski lemma reveals a strong flavor of <a href="https://en.wikipedia.org/wiki/Diagonal_argument" rel="external nofollow noopener" target="_blank">diagonal arguments</a>, hinting at a uniformity between the Baire category proof of the uncountablility of the reals and the more familiar diagonalization proof. This analogy underlies much of the study of what’s known today as forcing axioms (see for instance the <a href="http://people.dm.unipi.it/dinasso/SWIP/Viale-slides.pdf" rel="external nofollow noopener" target="_blank">exposition by Viale</a>).</p> <p>The resulting sequence obtained by piecing together the generic filter is now called a Cohen (generic) real over $M$. Due to later works of Solovay, we now know in hindsight that if $M$ is a countable transitive model of $\mathsf{ZFC}$, then in the sense of topology almost every real number is generic over $M$.</p> <hr> <h2 id="what-about-all-the-sets-generated-by-the-generic-object">What about all the sets generated by the generic object?</h2> <p>Forcing is a tool to build new models out of old ones. So far, we started with a countable transitive model, and motivated the notion of generic filters. Such filters exist, and the resulting object is perfectly average in a precise sense. But we’ve only built an infinite binary sequence. How do we build new models of $\mathsf{ZFC}$?</p> <p>In the above, we observed that it is not enough to just add the generic object to $M$. We need to add things that are generated by it. A doomed attempt is to try to find some way and describe what one needs to add to $M$: i.e., if $f$ is the generic sequence, we require that $\{f\}$ be in the new model, $\{\{f\}\}$ be in the new model, etc etc. This is doomed, because the $\mathsf{ZFC}$ axioms are so complicated that there is simply o hope for some tangible description to round out what one needs to add to $M$ in order to obtain a model of $\mathsf{ZFC}$. What’s missing, then, is some kind of process that “takes care of itself”, so to speak.</p> <p>The incredibly ingenious realization by Cohen was that, just like the generic object is built using partial information, so can the entire extension model of $M$. To unuderstand this, we need to understand a theorem (really an axiom) of $\mathsf{ZFC}$: every set can be obtained in the following recursive process, carried out transfinitely:</p> <ol> <li>stage 0: take the empty set</li> <li>stage $\alpha+1$: take all the subsets of the things in stage $\alpha$</li> <li>at limit stage $\lambda$: collect all things gathered so far.</li> </ol> <p>The familiar reader will notice that this is an informal description of the <a href="https://en.wikipedia.org/wiki/Von_Neumann_universe" rel="external nofollow noopener" target="_blank">von Neumann hierarchy</a>, where: $V_0=\emptyset$, $V_{\alpha+1}=\mathcal{P}(V_\alpha)$, and $V_\lambda = \bigcup_{\beta&lt;\lambda}V_\beta$ for limit ordinals $\beta$.</p> <details><summary style="cursor: pointer">Conceptual and Technical Difficulties</summary> <div style="margin-left: 1em;"> We are slowly getting into the unfamiliar territory of definition by transfinite recursion and proof by transfinite induction. The reader who has never heard of the term ordinal might be at a loss here. In more familar recursions and inductions, one moves along the natural numbers. The ordinals, simply put, are objects that mark the steps of a recursion or induction that goes on longer than the natural numbers. <br><br> Some math textbooks will cover transfinite recursion or transfinite induction (for instance in Terrence Tao's Analysis). But more likely than not, transfinite recursion and induction will take a little getting used to. Moreover, the transfinite recursions to come will be massively more complicated than what one typically encounters in real analysis or formal logic. This might create a sense of unease for the faint of heart. </div> </details> <p><br></p> <p>It is an axiom of $\mathsf{ZFC}$ that every set belongs to one of these stages. Intuitively, the von Neumann hierarchy describes a process building a model of $\mathsf{ZFC}$. Cohen decided to mimic this process, using the generic sequence we obtained.</p> <hr> <h2 id="enter-the-names">Enter the Names</h2> <p>The trick here requires a new perspective. That is, we no longer view the statement $x\in X$ as a proposition, but we view it as expressing a degree of truth. Of course, in the classical case, to assert $x\in X$ is to assert that $x\in X$ is true to degree 1, and to assert $x\notin X$ is to assert that $x\in X$ is true to degree 0 (i.e., not true at all).</p> <p>That is, we would like to identify each set $X\in M$ with its characteristic function $char_X: X\to\{0,1\}$, where $char_X(x)=1$ if and only if $x\in X$. Since this is set theory, mind you, functions are really just sets of ordered pairs. So we shall view a set $X$ as the set $X \times \{0,1\}$, and we take the “true” elements of $X$ to be those that are paired with $1$.</p> <p>One way to “extend” $M$ (in scare quotes because we are not really adding anything), is to do this for each element of $M$, so we end up getting the set of “possible elements of $M$”:</p> <p>$\{(x,i)\mid i\in \{0,1\}~\&amp;~ x\in M\}$</p> <p>We can view these possible elements of $M$ as being undetermined whether they are in $M$ or not (so a little bit like Schrödinger’s poor cat), waiting to be given a “truth value” as to the question “am I in $M$?” One can also think of them as <em>names</em> of elements that will go into $M$, waiting to be called out by some kind of selector.</p> <p>Of course, it is trivial to recover $M$ from the set of its possible elements: just take all the $(x,1)$, and take the left coordinate.</p> <p>Let’s pause here and reflect the above way of thinking. We have a way of naming the possible elements of $M$, and we can recover $M$ by designating a privileged “truth value” to pick out what names we call out (in our case $1$). Our target is to modify this strategy so that it names the possible elements of the bigger model extending $M$, and we would like to find some ways to use the generic filter as well.</p> <p>There is a shortcoming with the current strategy: it’s not expressive enough. By this I mean the names are taking the following form: $(a,b)$ where $a$ is an element of $M$, and $b$ is either $0$ or $1$. In their present form, they are too closely tied to the elements of $M$ to let us name an element that is not in it. It also relies too much of $M$: in order to “extend” $M$, we need to first have $M$ ready to form the names and call out the correct ones. These defects doom the current strategy as a way of <em>building/talking about a structure before we have it</em>.</p> <p>Recall that it is wise to leave the construction of the extension model to a process that somehow “takes care of itself”. And a sensible candidate is to imitate the von Neumann hierarchy in a way that reflects the recursive nature of the construction. The essential idea of the von Neumann hierarchy is this:</p> <ul> <li>Build things in stages. At each stage, use only what is available at that stage.</li> </ul> <p>So our current strategy fails to capture this guiding principle, because it is consider every element of $M$ at once, ignoring the hierarchical nature of the sets.</p> <p>So let us mimic the von Neumann hierarchy, but not in the construction of the new sets, but in the construction of the <em>names</em>.</p> <blockquote> <p>Definition. Call the two element poset $\{0,1\}$ <em>the truth value poset</em></p> </blockquote> <blockquote> <p>Definition. Let us consider the Name hierarchy for the truth value poset:</p> <ol> <li>$\text{Name}_0$ contains only the empty set. The empty set is the only level $0$ name.</li> <li>$\text{Name}_{\alpha+1} = \mathcal{P}(\text{Name}_\alpha\times \{0,1\})$.</li> <li>For limit ordinals $\lambda$, $\text{Name}_\lambda=\bigcup_{\beta&lt;\lambda}\text{Name}_\beta$.</li> </ol> </blockquote> <p>Of course, the name hierarchy described above is solely restricted to the truth value poset, and intended as an illustration.</p> <details><summary style="cursor: pointer">Conceptual Difficulty</summary> <div style="margin-left: 1em;"> The definition of names is probably one of the greatest challenges for someone seeing forcing for the first time. <br><br> The key point is that the construction of the names fully mimics the construction of the von Neumann hierarchy. At stage 0, we take the empty set and declare that to be a name. At stage $\alpha+1$, we take the names obtained in the previous stage, pair those with either $0$ or $1$, take arbitrary collections of the results, and declare these to be names of level $\alpha+1$. At limit stages, gather all names we've obtained so far. <br><br> In some texts, names are given the following definition: given a poset $\mathbb{P}$, a $\mathbb{P}$-name is any (possibly empty) set of ordered pairs of the form $(\sigma, p)$, where $\sigma$ is a $\mathbb{P}$-name and $p\in \mathbb{P}$. This seemingly circular definition is secured by noting that the empty set is a name, and names are built in the hierarchical way described above. An analogous description of what a **set** is might help: the empty set is a set; a set is anything that contains elements of the form $x$, where $x$ is a set. <br><br> I've attempted to tell a somewhat motivating story as how names come about. It's also interesting to note what Cohen himself remarked, on the discovery of (something in the spirit of) the name hierarchy: <br><br> "There are certainly moments in any mathematical discovery when the resolution of a problem takes place at such a subconscious level that, in retrospect, it seems impossible to dissect it and explain its origin. Rather, the entire idea presents itself at once, often perhaps in a vague form, but gradually becomes more precise. <br> This idea as it presented itself to me, appeared so different from any normal way of thinking, that I felt it could have enormous consequences." </div> </details> <p><br></p> <hr> <h2 id="evaluation-by-a-generic-filter">Evaluation by a generic filter</h2> <p>So we’ve improved our description of the names of the possible elements in the “extension” of $M$. This is done by mimicking the von Neumann construction of the sets. But what we have are just names so far. We don’t have a model yet. We need a way, again, to turn names into real elements.</p> <blockquote> <p>Definition. The filter $T$ on the truth value poset is the set $\{1\}$.</p> </blockquote> <p>To recover $M$ from the names for the truth value poset, we also follow von Neumann’s guiding principle. This is sensible, because the names themselves are constructed recursively in a hierarchical fashion.</p> <p>Note that we can’t just say “take left elements that are paired with $1$” like before, since these left elements are also themselves names. One needs to recursively give the names values like the following:</p> <p>1. $M_0$ contains only the empty set. That is, the empty set (as a name) gets evaluated by the filter $T$ to be the empty set.</p> <p>2. $M_{\alpha+1}$ contains the $T$-evaluation of the names in $\text{Name}_\alpha$ in the following sense: if $\tau$ is a name in stage $\text{Name}_{\alpha+1}$, then its $T$-evaluation is the $T$-evaluation of set of names in it. Or in symbols:</p> <p>$val_T(\tau) = \{val_T(\sigma) \mid (\sigma, 1)\in \tau\}$</p> <p>3. At limit stage, $M_\lambda$ is the set of all evaluations of the stages before $\lambda$.</p> <p>One may verify, somewhat tediously, that the set of evaluations of the names is exactly $M$.</p> <hr> <h2 id="generic-extensions">Generic Extensions</h2> <p>So we’ve improved our method of naming possible elements of a model and then instantiating them to be really elements of a model. This was done in the toy example with the truth value poset $\{0,1\}$ and the filter $T=\{1\}$. Forcing builds new models by taking more complicated posets and using generic filters on them as valuations. For instance:</p> <blockquote> <p>Definition. The name hierarchy for the Cohen poset $\mathbb{C}$ is defined recursively as follows</p> <ol> <li>$\text{Name}_0$ contains only the empty set. The empty set is the only level $0$ name.</li> <li>$\text{Name}_{\alpha+1} = \mathcal{P}(\text{Name}_\alpha\times \mathbb{C})$</li> <li>For limit ordinals $\lambda$, $\text{Name}_\lambda=\bigcup_{\beta&lt;\lambda}\text{Name}_\beta$</li> </ol> </blockquote> <p>Notice that, in the view that we are setting up, elements in the Cohen poset itself takes the role of truth values. So we still think of a statement of the form $x\in X$ as an assertion of a degree of truth; however, we no longer think of “degrees of truth” as being just the set $\{0,1\}$. We abstractly take the “degrees of truth” to be the Cohen poset.</p> <p>And if $G$ is a $M$-generic filter of the Cohen poset, the set of evaluations of the names in $M$, which we shall call the <em>generic extension</em> of $M$ by $G$ (in symbols, $M[G]$), is also obtained recursively.</p> <p>1. $M[G]_0$ contains only the empty set. That is, the empty set (as a name) gets evaluated by the filter $G$ to be the empty set.</p> <p>2. $M[G]_{\alpha+1}$ contains the $G$-evaluation of the names in $\text{Name}_\alpha$ in the following sense: if $\tau$ is a name in stage $\text{Name}_{\alpha+1}$, then its $G$-evaluation is the $G$-evaluation of set of names in it. Or in symbols:</p> <p>$val_G(\tau) = \{val_G(\sigma) \mid \exists s\in G~ (\sigma, s)\in \tau\}$</p> <p>3. At limit stage, $M[G]_\lambda$ is the set of all evaluations of the stages before $\lambda$.</p> <p>$M[G]$ denotes the union of all such $M[G]_\alpha$’s. The term “forcing” derives from the following definition of the relation between the poset in question and what $M[G]$ satisfies.</p> <blockquote> <p>Definition. If $s$ is an element of the Cohen poset and $P$ is a statement about elements of $M[G]$, then we write $s\Vdash P$ (“$s$ forces $P$”) to mean: every generic filter $G$ having $s$ as an element will make $M[G]$ satisfy $P$.</p> </blockquote> <p>In many texts at this point, basic properties of $M[G]$ will be established. The most important ones are:</p> <ol> <li>$M[G]$ is countable transitive. $G\in M[G]$. $M\subseteq M[G]$. And any transitive model satisfying these conditions will contain $M[G]$.</li> <li>$M[G]$ satisfies $\mathsf{ZFC}$.</li> </ol> <p>The proof of 2 is far from trivial. It requires a careful study of the relation between $M, G,$ and $M[G]$, as well as the forcing relation. A key component is the The Truth Lemma and the Definability Lemma, which jointly say that the forcing relation $s \Vdash P$ turns out to be equivalent to a topological property of the poset in question. This makes it a mathematical property that $M$ can handle using the $\mathsf{ZFC}$ axioms, rather than a metamathematical property about countable transitive models.</p> <details><summary style="cursor: pointer">Technical Difficulty</summary> <div style="margin-left: 1em;"> The majority of the time and energy on a first go at forcing will be spent on these facts, which involve very tedious proofs by induction. In particular, the equivalent topological property given by the truth and definiability lemmas will involve complex recursive definitions that are not intuitively clear at all. </div> </details> <p><br></p> <hr> <h2 id="forcing-more-generally">Forcing more generally</h2> <p>So that is how forcing builds new models of $\mathsf{ZFC}$ out of old ones. I should stress that we’ve only looked at forcing with toy examples, namely the Cohen poset and the truth value poset. Forcing itself is incredibly versatile, in that one can use forcing with whatever poset one desires, and sophisticated arguments and extensions have been produced using clever designs of posets. For instance, let me say a little bit about how one obtains a model in which $2^{\aleph_0}\neq \aleph_1$ (so the continuum hypothesis fails in that model).</p> <p>This is done by considering a suitable product of the Cohen poset.</p> <ul> <li>$M$ thinks that there is a poset that is $\aleph_2$-many copies of the Cohen poset.</li> <li>Forcing with it produces a generic extension that has that many infinite $0-1$ sequences, and hence that many real numbers.</li> <li>One then checks that the generic filter $G$ is not too informative as to disturb the calculation of what $\aleph_2$ (“the second uncountable cardinal”) is between $M$ and $M[G]$. This step is necessary because as we’ve seen, adding things to $M$ might reveal the countability of elements of $M$.</li> <li>This is ensured by appealing to the truth lemma and the definability lemma, and using a topological property of the poset known as the <a href="https://en.wikipedia.org/wiki/Countable_chain_condition" rel="external nofollow noopener" target="_blank">countable chain condition</a>.</li> <li>So one concludes that, in $M[G]$, $2^{\aleph_0}\geq \aleph_2$.</li> </ul> <p>I should also point out that the approach outlined in this post, namely the approach using countable transitive models, is one of several equivalent approaches to forcing. Some others are:</p> <ul> <li>Syntactic forcing.</li> </ul> <p>In syntactic forcing, one completely dispenses with any talks of models or truth in a model. Rather, one proceeds directly to the topological property given by the truth lemma and the definability lemma, making forcing really the study of topology and the Unicodes of formulas.</p> <p>Pro: no need to talk about countable transitive models or the existence of generics any more.<br> Con: involves complicated coding and translating semantics notions (such as truth) into somewhat stilted syntactic notions that are not very intuitive.</p> <ul> <li>Boolean-valued models.</li> </ul> <p>In this approach, one takes the truth value metaphor seriously. If one forces with the special class of posets known as the complete Boolean algebras, one can make precise the notion of a Boolean-valued characteristic function (which is what names are in this approach) and the corresponding Boolean-valued model. So names end up playing the roles of actual elements in a Boolean-valued model. This was invented by Solovay and Scott shortly after Cohen’s invention of forcing, in order to get a conceptually perspicuous way in thinking about what forcing is really doing.</p> <p>Pro: it is easier to understand what forcing is trying to do in this way, and if one has category-theoretic backgrounds, this is arguably the most natural way of understanding forcing. In addition, many of the results from the study of Boolean algebras can be applied to the study of generic extensions, a connection that is obscured in the countable transitive model approach.<br> Con: substantial prerequisites in the theory of complete Boolean algebras, including the separative quotient of a poset, regular open completion of a separative poset, etc.</p> <ul> <li>Boolean-valued ultrapowers.</li> </ul> <p>This is a slight variant of Boolean-valued models. One uses the Boolean analogue of the ultrapower construction to obtain an (uncountable) model over which generics exist. Joel Hamkins provided a <a href="https://arxiv.org/abs/1206.6075" rel="external nofollow noopener" target="_blank">naturalist account of forcing</a> based on this idea.</p> <hr> <h2 id="so-i-am-ready-to-learn-forcing--have-learned-forcing-what-now">So I am ready to learn forcing / have learned forcing. What now?</h2> <ul> <li>For an introductory text, Kunen’s <em>Set Theory: An Introduction to Independence Proofs</em> is really hard to beat. This book takes the countable transitive model approach, but has a section devoted to addressing other approaches.</li> <li>Jech’s <em>Set Theory: The Third Millennium Edition</em> is another classic. This encyclopedia of a book contains an introductory chapter to forcing and uses the Boolean-valued approach.</li> <li>If Kunen’s and Jech’s books are too long or detailed, two other shorter, more focused alternatives are: <em>Forcing for Mathematicians</em> by Weaver and <em>Fast Track to Forcing</em> by Džamonja. Besides being both dedicated to an introduction to forcing, the former has the advantage of surveying many actual mathematical problems that are proven to be independent using forcing and has a few chapters on forcing axioms; and the latter surveys many sophisticated posets invented by set theorists.</li> <li> <a href="http://kamerynjw.net/teaching/2019/math655/" rel="external nofollow noopener" target="_blank">This set of lecture notes</a> by Kameryn Williams. Very compact and self-contained material that takes one from logical preliminaries all the way to applications of forcing to the study of large cardinals (what a ride!). It has a section devoted to the introduction of forcing.</li> <li>Intermediate extensions or symmetric submodels. If $M$ satisfies $\mathsf{ZFC}$, then $M[G]$ does too. So it might seem that independence results about the axiom of choice cannot be obtained by forcing. This is not the case, as (Cohen proved) one can look at models of set theory between $M$ and $M[G]$ in a systematic way, to obtain models where the axiom of choice fails. This subject is treated in Jech’s <em>The Axiom of Choice</em>. The tour de force of this line of thought is no doubt <a href="https://www.jstor.org/stable/1970696" rel="external nofollow noopener" target="_blank">Solovay’s classic 1970 paper on the Annals of Mathematics</a>, where he produced a model where every set of the real numbers is Lebesgue measurable (and much more!).</li> <li>Applications of forcing to mathematics. The later chapters of Weaver’s book contain proofs of independence of some open problems. Forcing also provides new tools to study sets of real numbers, which is the topic of Miller’s book <a href="https://people.math.wisc.edu/~miller/res/dstfor.pdf" rel="external nofollow noopener" target="_blank">Descriptive Set Theory and Forcing: How to prove theorems about Borel sets the hard way.</a>. A more comprehensive overview of set-theoretic tools used in real analysis, see <a href="https://arxiv.org/abs/1801.09149" rel="external nofollow noopener" target="_blank">Set Theory and the Analyst</a>.</li> <li>The proliferation of generic extensions makes these extensions and the forcing method themselves interesting objects of study. This is a subfield known as <a href="https://arxiv.org/abs/1107.4776" rel="external nofollow noopener" target="_blank">Set-theoretic Geology</a>. See also <a href="https://arxiv.org/abs/math/0509616" rel="external nofollow noopener" target="_blank">The Modal Logic of Forcing</a>.</li> <li>The proliferation of generic extensions also invites the question: are the axioms of set theory more similar to the axioms of group theory than the axioms of real numbers? If so, what can one say about the truth/falsity of independent statements, such as the continuum hypothesis? A provocative view comes from Joel Hamkins in his influential paper <a href="https://arxiv.org/abs/1108.4223" rel="external nofollow noopener" target="_blank">The Set-theoretic Multiverse</a>. This whole debate is nicely recounted in the early sections of <a href="https://www.cambridge.org/core/journals/bulletin-of-symbolic-logic/article/reconstruction-of-steels-multiverse-project/4309A83D64CFE43F0EF2544DAD301F60" rel="external nofollow noopener" target="_blank">A Reconstruction of Steel’s Multiverse Project</a> by Maddy and Meadows. The same sections also contain a riveting narrative of how the independence phenomenon influenced the development of set theory and set theorists’ thinking.</li> <li>And much much more!</li> </ul> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> </div> <footer class="sticky-bottom mt-5"> <div class="container"> © Copyright 2025 Jason Zesheng Chen. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Last updated: July 15, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-Fy6S3B9q64WdZWQUiU+q4/2Lc9npb8tCaSX9FK7E8HnRr0Jz8D6OP9dO5Vg3Q9ct" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-HDQ0NEVMD4"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-HDQ0NEVMD4");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>